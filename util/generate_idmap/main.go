package main

import (
	"fmt"
	"os"
	"strings"
	"io/ioutil"
)

const header = `
package protocol

import "reflect"

// Code generated by util/generate_idmap/main.go DO NOT EDIT.
//go:generate go run ../util/generate_idmap/main.go
`

type Entry struct {
	Direction string
	State string
	ID string
	Type string
}

func parseSource(fn string) ([]Entry, error) {
	entries := make([]Entry, 0)

	temp, err := ioutil.ReadFile(fn)
	if err != nil {
		return nil, err
	}
	content := string(temp)

	var currentType string
	for _, line := range strings.Split(content, "\n") {
		if strings.Contains(line, "struct") { // Struct Definition
			currentType = strings.Split(line, " ")[1]
		}

		if strings.Contains(line, "//generator:idmap") { // Magic Comment
			entry := Entry{Type: currentType}
			words := strings.Split(line, " ")

			for _, word := range words {
				if strings.Contains(word, "=") {
					tag := strings.Split(word, "=")

					if tag[0] == "Direction" {
						entry.Direction = tag[1]
					} else if tag[0] == "State" {
						entry.State = tag[1]
					} else if tag[0] == "ID" {
						entry.ID = tag[1]
					}
				}
			}

			entries = append(entries, entry)
		}
	}

	return entries, nil
}

func generateIDToPacketType(entries []Entry) string {
	res := `
func idToPacketType(direction Direction, state State, id int32) reflect.Type {
t := map[State]map[Direction]map[int32]reflect.Type{`


	for _, state := range []string{"Handshaking", "Status", "Login", "Play"} {
		res += fmt.Sprintf("%s: map[Direction]map[int32]reflect.Type{\n", state)

		for _, direction := range []string{"Clientbound", "Serverbound"} {
			res += fmt.Sprintf("%s: map[int32]reflect.Type{\n", direction)

			for _, entry := range entries {
				if entry.Direction == direction && entry.State == state {
					res += fmt.Sprintf("%s: reflect.TypeOf(%s{}),\n", entry.ID, entry.Type)
				}
			}

			res += "},"
		}

		res += "},"
	}

	res += `}; return t[state][direction][id]}`

	return res
}

func generatePacketToId(entries []Entry) string {
	res := `
func packetToID(direction Direction, state State, packet Packet) int32 {
ref_type := reflect.TypeOf(packet)
t := map[State]map[Direction]map[reflect.Type]int32{`

	for _, state := range []string{"Handshaking", "Status", "Login", "Play"} {
		res += fmt.Sprintf("%s: map[Direction]map[reflect.Type]int32{\n", state)

		for _, direction := range []string{"Clientbound", "Serverbound"} {
			res += fmt.Sprintf("%s: map[reflect.Type]int32{\n", direction)


			for _, entry := range entries {
				if entry.Direction == direction && entry.State == state {
					res += fmt.Sprintf("reflect.TypeOf(%s{}): %s,\n", entry.Type, entry.ID)
				}
			}

			res += "},"
		}

		res += "},"
	}

	res += `}; return t[state][direction][ref_type]}`

	return res
}

func main() {
	entries, err := parseSource("packet.go")
	if err != nil {
		panic(err)
	}

	result := header

	result += generatePacketToId(entries)
	result += generateIDToPacketType(entries)

	ioutil.WriteFile("packet_idmap.go", []byte(result), os.ModePerm)
}
