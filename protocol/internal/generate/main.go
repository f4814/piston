package main

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strconv"
	"strings"

	log "github.com/sirupsen/logrus"
)

var typeMap = map[string]string{
	"VarInt":         "int32",
	"String":         "string",
	"Long":           "int64",
	"UnsignedShort":  "uint16",
	"Int":            "int32",
	"Boolean":        "bool",
	"Array NBT":      "[]interface{}",
	"Array Byte":     "[]byte",
	"UnsignedByte":   "uint8",
	"Float":          "float32",
	"Byte":           "byte",
	"Position":       "Position",
	"Double":         "float64",
	"Identifier":     "string",
	"Angle":          "byte",
	"Short":          "int16",
	"UUID":           "string",
	"EntityMetadata": "string",
	"NBTTag":         "interface{}",
	"interface":      "interface{}",
}

type Packet struct {
	xml.Name    `xml:"packet"`
	PacketName  string `xml:"name"`
	Generator   string `xml:"generator,attr"`
	Description string `xml:"description,omitempty"`
	ID          struct {
		Direction   string `xml:"direction,attr"`
		State       string `xml:"state,attr"`
		Description string `xml:"description"`
		Hex         string `xml:"hex"`
	} `xml:"id"`
	Fields []struct {
		Type        string `xml:"type,attr"`
		Name        string `xml:"name"`
		Description string `xml:"description,omitemtpy"`
	} `xml:"field"`
}

type Packets struct {
	xml.Name `xml:"packets"`
	Packets  []Packet `xml:"packet"`
}

type Direction = string
type State = string
type Name = string

type Generator struct {
	Packets map[State]map[Direction]map[int]Name
	buffer  string
}

func NewGenerator() *Generator {
	buffer := "package protocol\n"
	buffer += "import (\"io\"\n)\n\n"
	buffer += "// Code generated by internal/generator DO NOT EDIT.\n\n"

	return &Generator{
		Packets: make(map[State]map[Direction]map[int]Name),
		buffer:  buffer,
	}
}

func (g *Generator) Register(state State, direction Direction, id int, name string) {
	if g.Packets == nil {
		g.Packets = make(map[State]map[Direction]map[int]Name)
	}

	if g.Packets[state] == nil {
		g.Packets[state] = make(map[Direction]map[int]Name)
	}

	if g.Packets[state][direction] == nil {
		g.Packets[state][direction] = make(map[int]Name)
	}

	g.Packets[state][direction][id] = name
}

func (g *Generator) GenerateType(packet Packet) {
	if packet.Description != "" {
		for _, v := range strings.Split(packet.Description, "\n") {
			if strings.TrimSpace(v) == "" { // Start and end blocks
				continue
			}
			g.write(fmt.Sprintf("// %s\n", strings.TrimSpace(v)))
		}
	}

	g.write(fmt.Sprintf("type %s struct {\n", packet.PacketName))

	for _, field := range packet.Fields {
		if field.Description != "" {
			for _, v := range strings.Split(field.Description, "\n") {
				if strings.TrimSpace(v) == "" { // Start and end blocks
					continue
				}
				g.write(fmt.Sprintf("// %s\n", strings.TrimSpace(v)))
			}
		}

		g.write(fmt.Sprintf("%s %s;\n\n", field.Name, typeMap[field.Type]))
	}

	g.write("}\n")

	g.write(fmt.Sprintf("// returns %s\n", packet.ID.Hex))
	g.write(fmt.Sprintf("func (p %s) id() int32 { return %s }\n", packet.PacketName, packet.ID.Hex))
}

func (g *Generator) GenerateMethods(packet Packet) {
	g.write(fmt.Sprintf("func (p *%s) decode(r io.Reader) (err error) {", packet.PacketName))

	for _, field := range packet.Fields {
		g.write(fmt.Sprintf("if p.%s, err = read%s(r); err != nil { return err };", field.Name, field.Type))
	}

	g.write("return}\n")

	g.write(fmt.Sprintf("func (p %s) encode(w io.Writer) (err error) {", packet.PacketName))

	for _, field := range packet.Fields {
		g.write(fmt.Sprintf("if err = write%s(w, p.%s); err != nil { return err };", field.Type, field.Name))
	}
	g.write("return }\n")
}

func (g *Generator) GenerateDecoder() {
	g.write("func packetDecoder(state State, direction Direction, id int32, r io.Reader) (Packet, error) {")

	// IDMAP
	g.write("switch (state) {\n")
	for state, stateMap := range g.Packets {
		g.write(fmt.Sprintf("case %s:\n", state))
		g.write("switch (direction) {\n")
		for direction, directionMap := range stateMap {
			g.write(fmt.Sprintf("case %s:\n", direction))
			g.write("switch (id) {\n")
			for id, packet := range directionMap {
				g.write(fmt.Sprintf("case %d: \n", id))
				g.write(fmt.Sprintf("var p %s\n", packet))
				g.write(fmt.Sprintf("err := p.decode(r)\n"))
				g.write("return p, err\n")
			}
			g.write("}\n")
		}
		g.write("}\n")
	}
	g.write("}\n")

	g.write("return nil, UnknownPacketError{ID: id, State: state}}")
}

func (g *Generator) write(s string) {
	g.buffer += s
}

func loadPackets() (packets Packets, err error) {
	file, err := os.Open("packets.xml")
	if err != nil {
		return
	}

	bytes, err := ioutil.ReadAll(file)
	if err != nil {
		return
	}

	err = xml.Unmarshal(bytes, &packets)
	if err != nil {
		return
	}

	return
}

func main() {
	packets, err := loadPackets()

	generator := NewGenerator()

	if err != nil {
		log.Fatal(err)
	}

	for _, v := range packets.Packets {
		log.WithFields(log.Fields{
			"packet":    v.PacketName,
			"generator": v.Generator,
		}).Debug("Found packet")

		id, err := strconv.ParseInt(v.ID.Hex, 0, 64)
		if err != nil {
			log.Fatal(err)
		}

		generator.Register(v.ID.State, v.ID.Direction, int(id), v.PacketName)

		generator.GenerateType(v)
		if v.Generator == "on" {
			generator.GenerateMethods(v)
		}
	}

	generator.GenerateDecoder()

	ioutil.WriteFile("packet_generated.go", []byte(generator.buffer), os.ModePerm)
	os.Chmod("packet_generated.go", 0644)

	err = exec.Command("gofmt", "-w", "packet_generated.go").Run()
	if err != nil {
		log.Error(err)
	}
}
